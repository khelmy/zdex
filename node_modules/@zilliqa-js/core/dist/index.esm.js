import fetch from 'cross-fetch';

var Signer = /** @class */ (function () {
    function Signer() {
    }
    return Signer;
}());
var TxBlockType;
(function (TxBlockType) {
    TxBlockType[TxBlockType["MICRO"] = 0] = "MICRO";
    TxBlockType[TxBlockType["FINAL"] = 1] = "FINAL";
})(TxBlockType || (TxBlockType = {}));
var TransactionError;
(function (TransactionError) {
    TransactionError[TransactionError["CHECKER_FAILED"] = 0] = "CHECKER_FAILED";
    TransactionError[TransactionError["RUNNER_FAILED"] = 1] = "RUNNER_FAILED";
    TransactionError[TransactionError["BALANCE_TRANSFER_FAILED"] = 2] = "BALANCE_TRANSFER_FAILED";
    TransactionError[TransactionError["EXECUTE_CMD_FAILED"] = 3] = "EXECUTE_CMD_FAILED";
    TransactionError[TransactionError["EXECUTE_CMD_TIMEOUT"] = 4] = "EXECUTE_CMD_TIMEOUT";
    TransactionError[TransactionError["NO_GAS_REMAINING_FOUND"] = 5] = "NO_GAS_REMAINING_FOUND";
    TransactionError[TransactionError["NO_ACCEPTED_FOUND"] = 6] = "NO_ACCEPTED_FOUND";
    TransactionError[TransactionError["CALL_CONTRACT_FAILED"] = 7] = "CALL_CONTRACT_FAILED";
    TransactionError[TransactionError["CREATE_CONTRACT_FAILED"] = 8] = "CREATE_CONTRACT_FAILED";
    TransactionError[TransactionError["JSON_OUTPUT_CORRUPTED"] = 9] = "JSON_OUTPUT_CORRUPTED";
    TransactionError[TransactionError["CONTRACT_NOT_EXIST"] = 10] = "CONTRACT_NOT_EXIST";
    TransactionError[TransactionError["STATE_CORRUPTED"] = 11] = "STATE_CORRUPTED";
    TransactionError[TransactionError["LOG_ENTRY_INSTALL_FAILED"] = 12] = "LOG_ENTRY_INSTALL_FAILED";
    TransactionError[TransactionError["MESSAGE_CORRUPTED"] = 13] = "MESSAGE_CORRUPTED";
    TransactionError[TransactionError["RECEIPT_IS_NULL"] = 14] = "RECEIPT_IS_NULL";
    TransactionError[TransactionError["MAX_DEPTH_REACHED"] = 15] = "MAX_DEPTH_REACHED";
    TransactionError[TransactionError["CHAIN_CALL_DIFF_SHARD"] = 16] = "CHAIN_CALL_DIFF_SHARD";
    TransactionError[TransactionError["PREPARATION_FAILED"] = 17] = "PREPARATION_FAILED";
    TransactionError[TransactionError["NO_OUTPUT"] = 18] = "NO_OUTPUT";
    TransactionError[TransactionError["OUTPUT_ILLEGAL"] = 19] = "OUTPUT_ILLEGAL";
})(TransactionError || (TransactionError = {}));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * sign
 *
 * This decorates a method by attempting to sign the first argument of the
 * intercepted method.
 *
 * @param {T} target
 * @param {K} key
 * @param {PropertyDescriptor} descriptor
 * @returns {PropertyDescriptor | undefined}
 */
var sign = function (target, key, descriptor) {
    var original = descriptor.value;
    function interceptor(arg) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var signed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(original && arg.bytes)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.signer.sign(arg)];
                    case 1:
                        signed = _a.sent();
                        return [2 /*return*/, original.call.apply(original, __spread([this, signed], args))];
                    case 2: return [2 /*return*/];
                }
            });
        });
    }
    descriptor.value = interceptor;
    return descriptor;
};

var _this = undefined;
/**
 * blockchain-side.
 */
var RPCMethod;
(function (RPCMethod) {
    // Network-related methods
    RPCMethod["GetNetworkId"] = "GetNetworkId";
    // Blockchain-related methods
    RPCMethod["GetBlockchainInfo"] = "GetBlockchainInfo";
    RPCMethod["GetShardingStructure"] = "GetShardingStructure";
    RPCMethod["GetDSBlock"] = "GetDsBlock";
    RPCMethod["GetLatestDSBlock"] = "GetLatestDsBlock";
    RPCMethod["GetNumDSBlocks"] = "GetNumDSBlocks";
    RPCMethod["GetDSBlockRate"] = "GetDSBlockRate";
    RPCMethod["DSBlockListing"] = "DSBlockListing";
    RPCMethod["GetTxBlock"] = "GetTxBlock";
    RPCMethod["GetLatestTxBlock"] = "GetLatestTxBlock";
    RPCMethod["GetNumTxBlocks"] = "GetNumTxBlocks";
    RPCMethod["GetTxBlockRate"] = "GetTxBlockRate";
    RPCMethod["TxBlockListing"] = "TxBlockListing";
    RPCMethod["GetNumTransactions"] = "GetNumTransactions";
    RPCMethod["GetTransactionRate"] = "GetTransactionRate";
    RPCMethod["GetCurrentMiniEpoch"] = "GetCurrentMiniEpoch";
    RPCMethod["GetCurrentDSEpoch"] = "GetCurrentDSEpoch";
    RPCMethod["GetPrevDifficulty"] = "GetPrevDifficulty";
    RPCMethod["GetPrevDSDifficulty"] = "GetPrevDSDifficulty";
    // Transaction-related methods
    RPCMethod["CreateTransaction"] = "CreateTransaction";
    RPCMethod["GetTransaction"] = "GetTransaction";
    RPCMethod["GetRecentTransactions"] = "GetRecentTransactions";
    RPCMethod["GetTransactionsForTxBlock"] = "GetTransactionsForTxBlock";
    RPCMethod["GetNumTxnsTxEpoch"] = "GetNumTxnsTxEpoch";
    RPCMethod["GetNumTxnsDSEpoch"] = "GetNumTxnsDSEpoch";
    RPCMethod["GetMinimumGasPrice"] = "GetMinimumGasPrice";
    // Contract-related methods
    RPCMethod["GetSmartContracts"] = "GetSmartContracts";
    RPCMethod["GetSmartContractCode"] = "GetSmartContractCode";
    RPCMethod["GetSmartContractInit"] = "GetSmartContractInit";
    RPCMethod["GetSmartContractState"] = "GetSmartContractState";
    RPCMethod["GetContractAddressFromTransactionID"] = "GetContractAddressFromTransactionID";
    // Account-related methods
    RPCMethod["GetBalance"] = "GetBalance";
})(RPCMethod || (RPCMethod = {}));
var RPCErrorCode;
(function (RPCErrorCode) {
    // Standard JSON-RPC 2.0 errors
    // RPC_INVALID_REQUEST is internally mapped to HTTP_BAD_REQUEST (400).
    // It should not be used for application-layer errors.
    RPCErrorCode[RPCErrorCode["RPC_INVALID_REQUEST"] = -32600] = "RPC_INVALID_REQUEST";
    // RPC_METHOD_NOT_FOUND is internally mapped to HTTP_NOT_FOUND (404).
    // It should not be used for application-layer errors.
    RPCErrorCode[RPCErrorCode["RPC_METHOD_NOT_FOUND"] = -32601] = "RPC_METHOD_NOT_FOUND";
    RPCErrorCode[RPCErrorCode["RPC_INVALID_PARAMS"] = -32602] = "RPC_INVALID_PARAMS";
    // RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind
    // (for example datadir corruption).
    RPCErrorCode[RPCErrorCode["RPC_INTERNAL_ERROR"] = -32603] = "RPC_INTERNAL_ERROR";
    RPCErrorCode[RPCErrorCode["RPC_PARSE_ERROR"] = -32700] = "RPC_PARSE_ERROR";
    // General application defined errors
    RPCErrorCode[RPCErrorCode["RPC_MISC_ERROR"] = -1] = "RPC_MISC_ERROR";
    RPCErrorCode[RPCErrorCode["RPC_TYPE_ERROR"] = -3] = "RPC_TYPE_ERROR";
    RPCErrorCode[RPCErrorCode["RPC_INVALID_ADDRESS_OR_KEY"] = -5] = "RPC_INVALID_ADDRESS_OR_KEY";
    RPCErrorCode[RPCErrorCode["RPC_INVALID_PARAMETER"] = -8] = "RPC_INVALID_PARAMETER";
    RPCErrorCode[RPCErrorCode["RPC_DATABASE_ERROR"] = -20] = "RPC_DATABASE_ERROR";
    RPCErrorCode[RPCErrorCode["RPC_DESERIALIZATION_ERROR"] = -22] = "RPC_DESERIALIZATION_ERROR";
    RPCErrorCode[RPCErrorCode["RPC_VERIFY_ERROR"] = -25] = "RPC_VERIFY_ERROR";
    RPCErrorCode[RPCErrorCode["RPC_VERIFY_REJECTED"] = -26] = "RPC_VERIFY_REJECTED";
    RPCErrorCode[RPCErrorCode["RPC_IN_WARMUP"] = -28] = "RPC_IN_WARMUP";
    RPCErrorCode[RPCErrorCode["RPC_METHOD_DEPRECATED"] = -32] = "RPC_METHOD_DEPRECATED";
})(RPCErrorCode || (RPCErrorCode = {}));
var DEFAULT_HEADERS = { 'Content-Type': 'application/json' };
var performRPC = function (request, handler) { return __awaiter(_this, void 0, void 0, function () {
    var response, err_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 2, , 3]);
                return [4 /*yield*/, fetch(request.url, {
                        method: 'POST',
                        cache: 'no-cache',
                        mode: 'cors',
                        redirect: 'follow',
                        referrer: 'no-referrer',
                        body: JSON.stringify(request.payload),
                        headers: __assign({}, DEFAULT_HEADERS, ((request.options && request.options.headers) || {})),
                    })];
            case 1:
                response = _a.sent();
                return [2 /*return*/, response
                        .json()
                        .then(function (body) {
                        return __assign({}, body, { req: request });
                    })
                        .then(handler)];
            case 2:
                err_1 = _a.sent();
                throw err_1;
            case 3: return [2 /*return*/];
        }
    });
}); };

function isValidResponse(response) {
    if (response.jsonrpc === '2.0' &&
        (response.id === '1' || response.id === 1) &&
        (response.error || response.result)) {
        return true;
    }
    return false;
}
function composeMiddleware() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    if (fns.length === 0) {
        return function (arg) { return arg; };
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return fns.reduce(function (a, b) { return function (arg) { return a(b(arg)); }; });
}

var MiddlewareType;
(function (MiddlewareType) {
    MiddlewareType[MiddlewareType["REQ"] = 0] = "REQ";
    MiddlewareType[MiddlewareType["RES"] = 1] = "RES";
})(MiddlewareType || (MiddlewareType = {}));
var BaseProvider = /** @class */ (function () {
    function BaseProvider(nodeURL, reqMiddleware, resMiddleware) {
        if (reqMiddleware === void 0) { reqMiddleware = new Map(); }
        if (resMiddleware === void 0) { resMiddleware = new Map(); }
        var _this = this;
        this.middleware = {
            request: {
                use: function (fn, match) {
                    if (match === void 0) { match = '*'; }
                    _this.pushMiddleware(fn, 0 /* REQ */, match);
                },
            },
            response: {
                use: function (fn, match) {
                    if (match === void 0) { match = '*'; }
                    _this.pushMiddleware(fn, 1 /* RES */, match);
                },
            },
        };
        this.nodeURL = nodeURL;
        this.reqMiddleware = reqMiddleware;
        this.resMiddleware = resMiddleware;
    }
    /**
     * pushMiddleware
     *
     * Adds the middleware to the appropriate middleware map.
     *
     * @param {ResMiddlewareFn}
     * @param {T} type
     * @param {Matcher} match
     * @returns {void}
     */
    BaseProvider.prototype.pushMiddleware = function (fn, type, match) {
        if (type !== 0 /* REQ */ && type !== 1 /* RES */) {
            throw new Error('Please specify the type of middleware being added');
        }
        if (type === 0 /* REQ */) {
            var current = this.reqMiddleware.get(match) || [];
            this.reqMiddleware.set(match, __spread(current, [fn]));
        }
        else {
            var current = this.resMiddleware.get(match) || [];
            this.resMiddleware.set(match, __spread(current, [fn]));
        }
    };
    /**
     * getMiddleware
     *
     * Returns the middleware that matches the matcher provided. Note that
     * middleware are called in order of specificity: string -> regexp ->
     * wildcard.
     *
     * @param {Matcher} match
     * @returns {[ReqMiddlewareFn[], ResMiddlewareFn[]]}
     */
    BaseProvider.prototype.getMiddleware = function (method) {
        var e_1, _a, e_2, _b;
        var reqFns = [];
        var resFns = [];
        try {
            for (var _c = __values(this.reqMiddleware.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), key = _e[0], transformers = _e[1];
                if (typeof key === 'string' && key !== '*' && key === method) {
                    reqFns.push.apply(reqFns, __spread(transformers));
                }
                if (key instanceof RegExp && key.test(method)) {
                    reqFns.push.apply(reqFns, __spread(transformers));
                }
                if (key === '*') {
                    reqFns.push.apply(reqFns, __spread(transformers));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _f = __values(this.resMiddleware.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {
                var _h = __read(_g.value, 2), key = _h[0], transformers = _h[1];
                if (typeof key === 'string' && key !== '*' && key === method) {
                    resFns.push.apply(resFns, __spread(transformers));
                }
                if (key instanceof RegExp && key.test(method)) {
                    resFns.push.apply(resFns, __spread(transformers));
                }
                if (key === '*') {
                    resFns.push.apply(resFns, __spread(transformers));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return [reqFns, resFns];
    };
    return BaseProvider;
}());

var HTTPProvider = /** @class */ (function (_super) {
    __extends(HTTPProvider, _super);
    function HTTPProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HTTPProvider.prototype.buildPayload = function (method, params) {
        return {
            url: this.nodeURL,
            payload: { id: 1, jsonrpc: '2.0', method: method, params: params },
        };
    };
    HTTPProvider.prototype.send = function (method) {
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            params[_i - 1] = arguments[_i];
        }
        var _a = __read(this.getMiddleware(method), 2), tReq = _a[0], tRes = _a[1];
        var reqMiddleware = composeMiddleware.apply(void 0, __spread(tReq));
        var resMiddleware = composeMiddleware.apply(void 0, __spread(tRes));
        var req = reqMiddleware(this.buildPayload(method, params));
        return performRPC(req, resMiddleware);
    };
    HTTPProvider.prototype.subscribe = function (event, subscriber) {
        throw new Error('HTTPProvider does not support subscriptions.');
    };
    HTTPProvider.prototype.unsubscribe = function (token) {
        throw new Error('HTTPProvider does not support subscriptions.');
    };
    return HTTPProvider;
}(BaseProvider));

// this constant is used to indicate the number of times to poll the
// blockchain for a transaction confirmation. this number has been selected by
// using a heuristic to calculate the approximate maximum amount of time it
// should take for a transaction to be confirmed, even during a PoW submission
// round.
var GET_TX_ATTEMPTS = 33;

export { Signer, TransactionError, sign, RPCMethod, RPCErrorCode, performRPC, isValidResponse, composeMiddleware, HTTPProvider, GET_TX_ATTEMPTS };
//# sourceMappingURL=index.esm.js.map
